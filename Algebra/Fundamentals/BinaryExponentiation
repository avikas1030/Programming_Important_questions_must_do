# Approach 1 - Recursive 
long long binpow(long long a, long long b) {
    if (b == 0)
        return 1;
    long long res = binpow(a, b / 2);
    if (b % 2)
        return res * res * a;
    else
        return res * res;
}

# Approach 2 - Iterative
long long binpow(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

# For moduler operation 
Problem 1 (MODEX) Link : http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3671
Code :

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}

int main(){
    ll t;
    cin>>t;
    while(t--){
        ll x,y,n;
        cin>>x;
        cin>>y;
        cin>>n;
        ll ans = binpow(x, y, n);
        cout<<ans<<endl;
    }
    return 0;
}

# problem Applying a permutation k times
Problem: You are given a sequence of length n. Apply to it a given permutation k times.

Solution: Simply raise the permutation to kth power using binary exponentiation, and then apply it to the sequence. This will give you a time complexity of O(nlog k)

# code - 
vector<int> applyPermutation(vector<int> sequence, vector<int> permutation) {
    vector<int> newSequence(sequence.size());
    for(int i = 0; i < sequence.size(); i++) {
        newSequence[i] = sequence[permutation[i]];
    }
    return newSequence;
}

vector<int> permute(vector<int> sequence, vector<int> permutation, long long k) {
    while (k > 0) {
        if (k & 1) {
            sequence = applyPermutation(sequence, permutation);
        }
        permutation = applyPermutation(permutation, permutation);
        k >>= 1;
    }
    return sequence;
}

# Leading and trailing Zeros ; Problem Link : https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1970
Apart from the novice programmers, all others know that you can’t exactly represent numbers raised to some high power. For example, the C function 
pow(125456, 455) can be represented in double data type format, but you won’t get all the digits of the result. However we can get at least some satisfaction 
if we could know few of the leading and trailing digits. This is the requirement of this problem.

Input
The first line of input will be an integer T < 1001, where T represents the number of test cases. Each of the next T lines contains two positive integers, n and k. 
n will fit in 32 bit integer and k will be less than 10000001.

Output
For each line of input there will be one line of output. It will be of the format LLL . . . T T T, where LLL represents the first three digits of n k and T T T represents 
the last three digits of n^k. You are assured that n k will contain at least 6 digits.

Sample Input
2
123456 1
123456 2
Sample Output
123...456
152...936

Code : 
#include <bits/stdc++.h>
using namespace std;

long long modpow(long long a, long long b, long long mod) {
    long long res = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int T;
    cin >> T;
    while (T--) {
        long long n, k;
        cin >> n >> k;

        // -------- LAST 3 DIGITS (using binary exponentiation mod 1000) --------
        long long last3 = modpow(n, k, 1000);

        // -------- FIRST 3 DIGITS (using logarithm technique) --------
        /*
            If x = n^k
            log10(x) = k * log10(n) = y
            fractional part = f = y - floor(y)
            first 3 digits = pow(10, f) * 100
        */
        double y = k * log10(n);
        double f = y - floor(y);  // fractional part

        int first3 = pow(10, f + 2); // +2 to get first 3 digits (×100)

        // --------- PRINT IN REQUIRED FORMAT ---------
        cout << first3 << "...";
        cout << setw(3) << setfill('0') << last3 << "\n";
    }
    return 0;
}

Chef and Riffles : 
Code : 
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;

    while (T--) {
        int N;
        long long K;
        cin >> N >> K;

        vector<int> p(N + 1);
        int half = N / 2;

        for (int i = 1; i <= N; i++) {
            if (i & 1)
                p[i] = (i + 1) / 2;
            else
                p[i] = half + i / 2;
        }

        vector<int> finalPos(N + 1);
        vector<bool> visited(N + 1, false);


        for (int i = 1; i <= N; i++) {
            if (visited[i]) continue;

            vector<int> cycle;
            int cur = i;

            while (!visited[cur]) {
                visited[cur] = true;
                cycle.push_back(cur);
                cur = p[cur];
            }

            int L = cycle.size();
            int shift = K % L;

            for (int j = 0; j < L; j++) {
                finalPos[cycle[j]] = cycle[(j + shift) % L];
            }
        }

        vector<int> ans(N + 1);
        for (int i = 1; i <= N; i++) {
            ans[finalPos[i]] = i;
        }

        for (int i = 1; i <= N; i++) {
            cout << ans[i] << " ";
        }
        cout << "\n";
    }

    return 0;
}

E. Decoding Genome : Recently a top secret mission to Mars has taken place. As a result, scientists managed to obtain some information about the Martian DNA. 
Now we know that any Martian DNA contains at most m different nucleotides, numbered from 1 to m. 
Special characteristics of the Martian DNA prevent some nucleotide pairs from following consecutively in this chain. 
For example, if the nucleotide 1 and nucleotide 2 can not follow consecutively in the Martian DNA, 
then the chain of nucleotides [1, 2] is not a valid chain of Martian DNA, but the chain of nucleotides [2, 1] can be a valid chain (if there is no corresponding restriction). The number of nucleotide pairs that can't follow in the DNA chain consecutively, is k.

The needs of gene research required information about the quantity of correct n-long chains of the Martian DNA. Your task is to write a program that will calculate this value.
Code : 
#include <bits/stdc++.h>
using namespace std;

static const long long MOD = 1000000007;

/* -------- Matrix Structure -------- */
struct Matrix {
    int size;
    vector<vector<long long>> mat;

    Matrix(int n) {
        size = n;
        mat.assign(n, vector<long long>(n, 0));
    }
};

/* -------- Matrix Multiplication -------- */
Matrix multiply(Matrix &A, Matrix &B) {
    int n = A.size;
    Matrix C(n);

    for (int i = 0; i < n; i++) {
        for (int k = 0; k < n; k++) {
            if (A.mat[i][k] == 0) continue;
            for (int j = 0; j < n; j++) {
                C.mat[i][j] =
                    (C.mat[i][j] + A.mat[i][k] * B.mat[k][j]) % MOD;
            }
        }
    }
    return C;
}

/* -------- Matrix Exponentiation -------- */
Matrix matrixPower(Matrix base, long long power) {
    int n = base.size;
    Matrix result(n);

    // Identity matrix
    for (int i = 0; i < n; i++)
        result.mat[i][i] = 1;

    while (power > 0) {
        if (power & 1)
            result = multiply(result, base);

        base = multiply(base, base);
        power >>= 1;
    }
    return result;
}

/* -------- Convert character to index -------- */
int getIndex(char c) {
    if ('a' <= c && c <= 'z') return c - 'a';
    return 26 + (c - 'A');
}

/* -------- Main -------- */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    long long n;
    int m, k;
    cin >> n >> m >> k;

    // If length is 1 → any character is valid
    if (n == 1) {
        cout << m << "\n";
        return 0;
    }

    // Step 1: Build transition matrix
    Matrix T(m);

    // Initially all transitions allowed
    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            T.mat[i][j] = 1;

    // Remove forbidden transitions
    for (int i = 0; i < k; i++) {
        string s;
        cin >> s;
        int from = getIndex(s[0]);
        int to   = getIndex(s[1]);
        T.mat[from][to] = 0;
    }

    // Step 2: Raise matrix to power (n - 1)
    Matrix R = matrixPower(T, n - 1);

    // Step 3: Sum all possible paths
    long long answer = 0;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            answer = (answer + R.mat[i][j]) % MOD;

    cout << answer << "\n";
    return 0;
}
